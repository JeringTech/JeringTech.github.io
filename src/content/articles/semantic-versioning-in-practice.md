---
mimo_pageDescription: Semantic versioning (semver) is the standard system for versioning software with public APIs. In this article, we describe how semver is used in practice. Along the way, we explain why it is used.
mimo_pageTitle: Semantic Versioning in Practice
mimo_pageID: semantic-versioning-in-practice
mimo_date: Mar 3, 2018
mimo_shareOnFacebook: true
mimo_shareOnTwitter:
    hashtags: semver
    via: JeringTech
mimo_additionalFontPreloads:
  - /resources/open-sans-v15-latin-italic.woff2
---

<!--
#region pre-release-phase-2
3.0.0
- Fixed bugs.
- Software finally production ready.

3.0.0-beta.2
- Improved performance.
- Made backward compatible changes.

3.0.0-beta.1
- Fixed bugs.
- Made backward incompatible changes.

3.0.0-beta.0
- All features complete and architectural plans have stabilized but software hasn't been rigorously tested and optimized.
- Made backward compatible changes.

3.0.0-alpha.1
- Made backward compatible changes.

3.0.0-alpha.0
- Features have been locked but features are incomplete and architectural plans have not stabilized.
- Made backward incompatible changes.
#endregion

#region maintenance-phase
2.1.0
- Marked a feature as deprecated.

2.0.0
- Fixed backward incompatible bugs

1.2.0
- Made backward compatible, non-bug-fix changes to private code.

1.1.0
- Added public API functionality.

1.0.1
- Made backward compatible bug fixes.

1.0.0
- Fixed bugs, improved performance.
- Made backward incompatible changes.
- Software finally production ready.
#endregion

#region pre-release-phase-1
1.0.0-beta.1
- Fixed bugs, improved performance.
- Made backward incompatible changes.

1.0.0-beta.0
- All features complete and architectural plans have stabilized but software hasn't been rigorously tested and optimized.
- Made backward compatible changes.

1.0.0-alpha.1
- Made backward compatible changes.

1.0.0-alpha.0
- Features have been locked but features are incomplete and architectural plans have not stabilized.
- Made backward incompatible changes.
#endregion

#region initial-development-phase
0.3.0 
- Made backward incompatible changes.

0.2.0 
- Made backward compatible changes.

0.1.0 
- Initial release.
#endregion
-->

[Semantic versioning](https://semver.org/) (semver) is the standard system for versioning software with
[public APIs](#public-api). In this article, we describe how semver is used in practice. Along the way, we explain why it is used. 
Here at Jering, we apply semver to all of our software that have public APIs. This article provides an insight into our use of semver.

## Terminology
We must first define some important semver terms:
### Public API 
A piece of software's *public API (public application programming interface)* is the portion of its surface area that is publically exposed for
programmatic access. For example, the public API of a web service could refer to a REST API, the public API of a library could refer to its public members, 
and the public API of a command line application could refer to the list of commands that it accepts.
### Private Code
A piece of software's *private code* is the portion of its code that isn't publically exposed. For example, the private code of a web service could include a 
repository layer, the private code of a library could refer to its private classes and members, and the private code of a command line application could 
include business logic.
### Version 
A *version* is a snapshot of a piece of software.
### Backward Compatible 
*Backward compatible* is an adjective for [version](#version)s. A version is backward compatible with a preceding version if its [public API](#public-api) is equal to 
or a superset of the preceding version's public API. In other words, a version is backward compatible with a preceding version if it can be used as a substitute for the preceding 
version. For example, a version that only adds public API features is backward compatible with its preceding version, while a version that removes or changes 
public API features isn't.
### Version Number 
A *version number* is an identifier for a [version](#version). Version numbers are strings of the form `major.minor.patch[-pre_release_identifiers][+build_metadata]`, 
where `major`, `minor` and `patch` are integers, and both `pre_release_identifiers` and `build_metadata` are series of dot-separated strings, 
where each string contains only characters in the regex character set `[0-9A-Za-z\-]`.

! The `build_metadata` segment of a version number is typically generated by [continuous integration](https://docs.microsoft.com/en-us/azure/devops/learn/what-is-continuous-integration)
! (CI) systems using a format like `YYYYMMDD-<build number for the day>`. `build_metadata` is often used to retrospectively identify the CI build that generated 
! a piece of software. Due to its arbitrariness, we do not discuss it any further in this article.
### Patch Version 
*Patch version* refers to the `patch` segment of a [version number](#version-number).
### Minor Version 
*Minor version* refers to the `minor` segment of a [version number](#version-number). 
### Major Version 
*Major version* refers to the `major` segment of a [version number](#version-number).
### Release 
A *release* is a production-ready [version](#version).
### Pre-release 
A *pre-release* is a non-production-ready [version](#version) that closely precedes a [release](#release).


## What Kind of Software Can Semver Be Used For?
We're about to start describing how semver is used in practice. Before we get into it though, we must clarify a common cause of frustration: 
Semver is designed for versioning software that declares a [public API](#public-api), such as a library. 
It can't be applied to a piece of software that doesn't declare a public API.

Examples of software that do not declare a public API include many games and websites. Consider a simple blog. Unlike a library, 
it has no public API. It isn't programmatically accessible to other pieces of software. As such, [version](#version)s of a blog can't be 
[backward compatible](#backward-compatible) or incompatible. Such software can't be versioned using semver because - as we will see 
later on in this article - semver [version number](#version-number)s [describe backward compatibility](#rules-2).

## Initial Development Phase
Okay, we've finally gotten the basics out of the way. Let's move on to how semver is used in practice. Semver has 3 phases: 
the *initial development phase*, the [*pre-release phase*](#pre-release-phase), and the [*maintenance phase*](#maintenance-phase). We begin by describing the initial 
development phase.

### Description
A piece of software is in this phase just after conception. Architectural plans and feature requirements are typically in flux. Development is rapid, and the 
software's [public API](#public-api) is very unstable. 

### Semver in this Phase
#### Rules
[Semver specifies](https://semver.org/#how-should-i-deal-with-revisions-in-the-0yz-initial-development-phase) that this phase should begin with [version number](#version-number)
`0.1.0`. During this phase, each subsequent version number should only have its [minor version](#minor-version) incremented. This should be the case regardless of whether or not changes 
are [backward compatible](#backward-compatible). For example, at the end of this phase, the [version](#version) history of a piece of software might look like this:

@{
    "highlightLineRanges": [{"startLineNumber": 1, "endLineNumber": 1}, 
        {"startLineNumber": 4, "endLineNumber": 4},
        {"startLineNumber": 7, "endLineNumber": 7}]
}
+{ "clippings": [{"region": "initial-development-phase"}] }

#### Rationale
- By keeping [major version](#major-version) at 0, you're letting consumers know that your software is likely to undergo significant changes. You're also letting them know that it isn't ready for use in 
production.
- By incrementing only minor version, you avoid the extra effort involved in picking [maintenance phase](#maintenance-phase) version numbers. 
This is convenient when you're iterating quickly. Additionally, it does not compromise on the availability of an ordered history.

## Pre-Release Phase

### Description
A piece of software is in this phase when it is working toward a [release](#release). Like in the 
[initial development phase](#initial-development-phase), development is rapid and the software's [public API](#public-api) is very unstable.
Versions in this phase are called [pre-release](#pre-release)s.

! This phase can occur after the initial development phase or after a [maintenance phase](#maintenance-phase). After the 
! initial development phase, a piece of software would be working toward the `1.0.0` release. After a maintenance phase, a piece of software could 
! be working toward any release. For example, it could be working toward `2.0.0`, `3.2.0`, or `4.5.1`.

### Semver in this Phase
#### Rules
During this phase, [semver specifies](https://semver.org/#spec-item-9) that [version number](#version-number)s should be the version number of the target release followed 
by a `-` and dot-separated pre-release identifiers. For example, `1.0.0-alpha.1`. Each subsequent version number should only have its pre-release 
identifiers incremented. This should be the case regardless of whether or not changes are backward compatible. For example, at the end of this phase, 
the version history of a piece of software might look like this:

@{
    "highlightLineRanges": [{"startLineNumber": 1, "endLineNumber": 1}, 
        {"startLineNumber": 5, "endLineNumber": 5},
        {"startLineNumber": 9, "endLineNumber": 9},
        {"startLineNumber": 12, "endLineNumber": 12}]
}
+{ 
    "clippings": [{"region": "pre-release-phase-1", "afterContent": ""}, 
        {"region": "initial-development-phase"}]
}

#### Rationale
- By appending pre-release identifiers, you're letting lets consumers know that a piece of software isn't ready for use in production.
At the same time, you're letting consumers know that the software has attained some semblance of stability (relative to the initial development phase).
- Like in the initial development phase, by incrementing only pre-release identifiers, you avoid the extra effort involved in picking 
[maintenance phase](#maintenance-phase) version numbers. Again, this is convenient when you're iterating quickly. Also, again, it does not compromise on the availability of an 
ordered history.

### Notes
You might have noticed that this phase isn't very well-demarcated from the initial development phase. After all, isn't a piece of software in the initial
development phase "working toward a release but not production ready yet"? Also, you might have noticed that this phase's sub-phases (alpha, beta, release candidate etc, also known as
pre-release sub-phases) aren't well defined.  

Semver does not specify a standard way to demarcate this phase from the initial development phase. Also, it does not specify standard definitions for pre-release sub-phases.
A lack of standardization across the industry has caused controversy before. For example, in [Angular 2+](https://angular.io/)'s 
early days, numerous breaking changes were made to release candidate versions. This caused a [backlash](https://www.reddit.com/r/Angular2/comments/4x23ae/eli5_why_are_new_featuresmajor_changes_being/)
from developers. They expected release candidates to have stable public APIs. We think it is a good idea to clearly articulate initial development/pre-release phase standards. 
Here at Jering, we mostly stick to the following:

We demarcate the initial development phase and this phase using the following marker:
- We advance a piece of software to the pre-release phase when its features have been locked. Apart from being a marker, we find that feature locking
is a great way to ensure that we complete projects.

We use the following definitions for pre-release sub-phases:
- We consider a piece of software to be in the alpha pre-release sub-phase if its features are incomplete and its architecture hasn't stabilized. 
- We consider a piece of software to be in the beta pre-release sub-phase if it's feature complete and its architecture has stabilized but it hasn't been 
rigorously tested and optimized.
- We do not use the release candidate pre-release phase. 

Software development can be unpredictable. As a result, it isn't always possible to stick to these standards. Nonetheless, we think they help
set expectations for consumers of Jering software.

## Maintenance Phase

### Description
A piece of software is in this phase when it's production ready. [Version](#version)s in this phase are called [release](#release)s. 
Typically, a piece of software in this phase has started being used by other software in production. As a result, [backward compatibility](#backward-compatible)
has started to matter.

### Semver in this Phase
#### Rules
Semver specifies that this phase should begin with a [version number](#version-number) of the form `major.minor.patch`, for example, `1.0.0`. During this phase, version numbers 
should be incremented according to the following rules:
- If a version adds only backward compatible bug fixes, its version number must be the preceding version number with its [patch version](#patch-version) incremented.
- If a version adds only backward compatible changes and at least one of these changes isn't a bug fix, its version number must be the preceding version number with its [minor version](#minor-version) incremented and its patch version set 
to 0. Examples of backward compatible, non-bug-fix changes include:
  - Adding public API functionality, for example, adding new endpoints to a REST API.
  - Making backward compatible, non-bug-fix changes to [private code](#private-code), for example, optimizing a private method in a library. 
  - Marking public API functionality as deprecated.
- If a version makes **any** backward incompatible changes, its version number must be the preceding version number with its [major version](#major-version) incremented, minor version set to 0, and patch version set to 0.

In short, if a version:

| Adds only Backward Compatible Changes | Adds only Bug Fixes | Action |
| ------------------------------------- | ------------------- | ------ |
| true | true | Increment patch version. |
| true | false | Increment minor version, set patch version to 0. |
| false | true/false | Increment major version, set minor version and patch version to 0. |

At the end of a maintenance phase, the version history of a piece of software might look like this:

@{
    "highlightLineRanges": [{"startLineNumber": 1, "endLineNumber": 1}, 
        {"startLineNumber": 4, "endLineNumber": 4},
        {"startLineNumber": 7, "endLineNumber": 7},
        {"startLineNumber": 10, "endLineNumber": 10},
        {"startLineNumber": 13, "endLineNumber": 13},
        {"startLineNumber": 16, "endLineNumber": 16}]
}
+{ 
    "clippings": [{"region": "maintenance-phase", "afterContent": ""}, 
        {"region": "pre-release-phase-1", "afterContent": ""}, 
        {"region": "initial-development-phase"}]
}

#### Rationale
- By incrementing major version whenever backward incompatible changes are made, you're making it possible for consumers to quickly deduce whether or not a version is backward compatible. 
Semver's ability to describe backward compatibility is a major reason why it is used. This ability enables consumers to automatically upgrade software to the newest possible backward compatible version. 

- By incrementing minor and patch versions according to whether or not a version contains only bug fixes, you're giving consumers fine-grained control over upgrading of versions. This is
less critical than semver's ability to describe backward compatibility. Nonetheless, some consumers find this control useful.

### Notes
Major version increments are often associated with significant changes and rewrites. Incrementing major version even for small, backward incompatible changes might seem unusual. 
Moreover, doing so could cause major version to balloon. You could end up with version numbers like `42.0.0`. That said, incrementing major version for every backward incompatible 
change in this phase is a critical rule. If it isn't followed, consumers in production could break because of unexpected backward incompatible changes.

Semver's FAQ
[mentions](https://semver.org/#if-even-the-tiniest-backwards-incompatible-changes-to-the-public-api-require-a-major-version-bump-wont-i-end-up-at-version-4200-very-rapidly) 
this issue. It suggests proper planning to minimize backward incompatible changes in this phase. Aside from proper planning, these practices could help:

- Avoid rushing into this phase. Whether or not a piece of software is production ready is subjective. This is not least because 
software can almost always be improved upon. Consider setting a high bar for production readiness and staying in the pre-release phase for longer. 
Doing so allows for more kinks to be ironed out before this phase.

- Batch backward incompatible changes. There is a downside to this - backward incompatible bug fixes could take longer to reach consumers. 
To mitigate this downside, a release cycle must be carefully planned.

Prior to any release, you can go through the [pre-release phase](#pre-release-phase) again. As mentioned in the [rationale](#rationale-1) for the pre-release phase,
it lets consumers know that your software isn't ready for use in production and it facilitates quick iterations. After a maintenance phase > pre-release phase > maintenance phase 
cycle, the version history of a piece of software might look like this:

@{
    "highlightLineRanges": [{"startLineNumber": 1, "endLineNumber": 1}, 
        {"startLineNumber": 5, "endLineNumber": 5},
        {"startLineNumber": 9, "endLineNumber": 9},
        {"startLineNumber": 13, "endLineNumber": 13},
        {"startLineNumber": 17, "endLineNumber": 17},
        {"startLineNumber": 20, "endLineNumber": 20}]
}
+{ 
    "clippings": [{"region": "pre-release-phase-2", "afterContent": ""},
        {"region": "maintenance-phase", "afterContent": ""},
        {"region": "pre-release-phase-1", "afterContent": ""},
        {"region": "initial-development-phase"}]
}

! A pre-release phase can take place in parallel with a maintenance phase. You would typically create two branches to make this happen. 
! On one, you'd continue fixing bugs for the ongoing maintenance phase. On the other, you'd add new features and tweak the public API in 
! a pre-release phase for an upcoming major version bump.

## Conclusion
Familiarity with semver has become a necessity for developers. We hope that we've been able to help you gain some with it. Also, we hope
that we've made it easier to confidently consume Jering software that have public APIs. Thanks for reading!

Have any questions or spot any mistakes? Submit a Github issue [here](https://github.com/JeringTech/Website/issues/new). If you found this article useful, consider sharing it! 